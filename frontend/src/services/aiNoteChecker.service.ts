import axios from 'axios';
import authService from './auth.service';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://0.0.0.0:5001';
const USE_MOCK_DATA = process.env.NODE_ENV === 'development' && process.env.REACT_APP_USE_MOCK_DATA === 'true';

// Types for AI Note Checker
export interface EligibleEncounter {
  encounterId: string;
  patientId: string;
  patientName: string;
  chiefComplaint: string;
  dateOfService: string;
  status: string;
  todoCreated?: boolean;
  todoCount?: number;
  hasValidIssues?: boolean;
}

export interface AIAnalysisIssue {
  assessment: string;
  issue: 'no_explicit_plan' | 'chronicity_mismatch' | 'unclear_documentation' | 'chief_complaint_structure';
  details: {
    HPI?: string;
    'A&P': string;
    correction: string;
  };
}

export interface AIAnalysisResult {
  issues?: AIAnalysisIssue[];
  status: 'ok' | 'corrections_needed';
  summary?: string;
  reason?: string; // Reason when status is 'ok'
}

export interface NoteCheckResult {
  id: number;
  encounterId: string;
  patientId: string;
  patientName: string;
  chiefComplaint: string;
  dateOfService: string;
  status: 'pending' | 'completed' | 'error';
  aiAnalysis?: AIAnalysisResult;
  issuesFound: boolean;
  checkedAt: string;
  checkedBy: string;
  errorMessage?: string;
}

export interface BatchProcessResult {
  processed: number;
  successful: number;
  failed: number;
  results: NoteCheckResult[];
}

export interface CareTeamMember {
  id: string;
  active: boolean;
  providerId: string;
  encounterId: string;
  encounterRoleType: 'PROVIDER' | 'SECONDARY_PROVIDER' | 'STAFF' | 'COSIGNING_PROVIDER';
  firstName: string;
  lastName: string;
  title?: string;
  onlineCheckInEnabled: boolean;
  fullOnlineCheckInEnabled: boolean;
}

export interface CreatedToDo {
  id: number;
  encounterId: string;
  patientId: string;
  patientName: string;
  ezDermToDoId: string;
  subject: string;
  description: string;
  assignedTo: string;
  assignedToName: string;
  ccList: any[];
  issuesCount: number;
  createdBy: string;
  createdAt: Date;
}

export interface InvalidIssue {
  id: number;
  encounterId: string;
  checkId: number;
  issueIndex: number;
  issueType: string;
  assessment: string;
  issueHash: string;
  markedInvalidBy: string;
  markedInvalidAt: Date;
  reason?: string;
}

export interface ProgressNoteResponse {
  progressNotes: Array<{
    sectionType: 'SUBJECTIVE' | 'OBJECTIVE' | 'ASSESSMENT_AND_PLAN';
    locked: boolean;
    order: number;
    items: Array<{
      elementType: string;
      text: string;
      autogenerated: boolean;
      maxCodingValue: number;
      suggestedCodingValue: number;
      order: number;
      note?: string;
      multipleItemValue: any[];
    }>;
  }>;
  groupCodes: {
    problemPointsV2: number;
    dataPointsV2: number;
    riskPointsV2: number;
    emCode: string;
  };
  encounterNonBillableStatuses: {
    active: boolean;
    encounterId: string;
    billableEncounter: boolean;
    emCoding: boolean;
  };
  patientId: string;
  notesCount: number;
}

class AINoteCheckerService {
  private readonly headers = () => {
    const token = authService.getSessionToken();
    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    };
  };

  // Mock data for development
  private mockEligibleEncounters: EligibleEncounter[] = [
    {
      encounterId: 'mock-encounter-1',
      patientId: 'mock-patient-1',
      patientName: 'John Doe',
      chiefComplaint: 'Follow-up psoriasis',
      dateOfService: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
      status: 'PENDING_COSIGN'
    },
    {
      encounterId: 'mock-encounter-2',
      patientId: 'mock-patient-2',
      patientName: 'Jane Smith',
      chiefComplaint: 'Skin lesion check',
      dateOfService: new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString(),
      status: 'CHECKED_OUT'
    },
    {
      encounterId: 'mock-encounter-3',
      patientId: 'mock-patient-3',
      patientName: 'Mike Johnson',
      chiefComplaint: 'Acne treatment',
      dateOfService: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
      status: 'WITH_PROVIDER'
    }
  ];

  private mockNoteCheckResults: NoteCheckResult[] = [
    {
      id: 1,
      encounterId: 'mock-encounter-1',
      patientId: 'mock-patient-1',
      patientName: 'John Doe',
      chiefComplaint: 'Follow-up psoriasis',
      dateOfService: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
      status: 'completed',
      aiAnalysis: {
        status: 'corrections_needed',
        issues: [
          {
            assessment: 'Psoriasis vulgaris',
            issue: 'chronicity_mismatch',
            details: {
              HPI: 'Patient presents for follow-up',
              'A&P': 'Listed as acute condition but history indicates chronic psoriasis',
              correction: 'Document as chronic condition and include duration'
            }
          }
        ],
        summary: 'Chronicity documentation needs correction for proper coding'
      },
      issuesFound: true,
      checkedAt: new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user'
    },
    {
      id: 2,
      encounterId: 'mock-encounter-2',
      patientId: 'mock-patient-2',
      patientName: 'Jane Smith',
      chiefComplaint: 'Skin lesion check',
      dateOfService: new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString(),
      status: 'completed',
      aiAnalysis: {
        status: 'ok'
      },
      issuesFound: false,
      checkedAt: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user'
    },
    {
      id: 3,
      encounterId: 'mock-encounter-3',
      patientId: 'mock-patient-3',
      patientName: 'Mike Johnson',
      chiefComplaint: 'Acne treatment',
      dateOfService: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
      status: 'error',
      issuesFound: false,
      checkedAt: new Date(Date.now() - 10 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user',
      errorMessage: 'Claude API rate limit exceeded'
    }
  ];

  /**
   * Get all incomplete notes from EZDerm (with pagination)
   */
  async getIncompleteNotes(): Promise<EligibleEncounter[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock incomplete notes');
      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
      return this.mockEligibleEncounters;
    }

    try {
      console.log('ðŸ“– Fetching ALL incomplete notes from EZDerm with pagination...');
      const response = await axios.post(`${API_BASE_URL}/notes/incomplete`, 
        { fetchAll: true },
        {
          headers: this.headers()
        }
      );

      const encounters = response.data.encounters || [];
      console.log(`ðŸ“‹ Fetched ${encounters.length} total encounters from EZDerm`);
      return encounters;
    } catch (error: any) {
      console.error('Error fetching incomplete notes:', error);
      throw new Error('Failed to fetch incomplete notes: ' + (error.response?.data?.error || error.message));
    }
  }

  /**
   * Get incomplete notes with manual pagination (for specific use cases)
   */
  async getIncompleteNotesPage(fetchFrom: number = 0, size: number = 100): Promise<EligibleEncounter[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock incomplete notes page');
      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
      return this.mockEligibleEncounters.slice(fetchFrom, fetchFrom + size);
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/incomplete`, 
        { fetchFrom, size },
        {
          headers: this.headers()
        }
      );

      return response.data.encounters || [];
    } catch (error: any) {
      console.error('Error fetching incomplete notes page:', error);
      throw new Error('Failed to fetch incomplete notes: ' + (error.response?.data?.error || error.message));
    }
  }

  /**
   * Get all encounters eligible for AI note checking
   */
  async getEligibleEncounters(): Promise<EligibleEncounter[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock eligible encounters');
      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
      return this.mockEligibleEncounters;
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/eligible`, {
        headers: this.headers()
      });

      return response.data.encounters || [];
    } catch (error: any) {
      console.error('Error fetching eligible encounters:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch eligible encounters');
    }
  }

  /**
   * Get progress note details for a specific encounter
   */
  async getProgressNote(encounterId: string, patientId?: string): Promise<{ progressNote: ProgressNoteResponse; careTeam: CareTeamMember[] }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock progress note');
      await new Promise(resolve => setTimeout(resolve, 800)); // Simulate API delay
      
      const mockCareTeam: CareTeamMember[] = [
        {
          id: 'mock-role-1',
          active: true,
          providerId: 'mock-provider-1',
          encounterId,
          encounterRoleType: 'PROVIDER',
          firstName: 'Dr. Sarah',
          lastName: 'Smith',
          title: 'MD',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        },
        {
          id: 'mock-role-2',
          active: true,
          providerId: 'mock-provider-2',
          encounterId,
          encounterRoleType: 'SECONDARY_PROVIDER',
          firstName: 'Jane',
          lastName: 'Wilson',
          title: 'NP',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        },
        {
          id: 'mock-role-3',
          active: true,
          providerId: 'mock-provider-3',
          encounterId,
          encounterRoleType: 'STAFF',
          firstName: 'Mike',
          lastName: 'Johnson',
          title: 'MA',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        }
      ];

      return {
        progressNote: {
          progressNotes: [
          {
            sectionType: 'SUBJECTIVE',
            locked: true,
            order: 1,
            items: [
              {
                elementType: 'HISTORY_OF_PRESENT_ILLNESS',
                text: 'Patient returns for follow-up of chronic psoriasis. Reports improved symptoms with current treatment.',
                autogenerated: true,
                maxCodingValue: 0,
                suggestedCodingValue: 0,
                order: 1,
                multipleItemValue: []
              }
            ]
          },
          {
            sectionType: 'ASSESSMENT_AND_PLAN',
            locked: true,
            order: 3,
            items: [
              {
                elementType: 'ASSESSMENT_AND_PLAN',
                text: '1. Psoriasis vulgaris\n\tâ€¢\tProblem: Chronic - Stable\n\tâ€¢\tPlan: Continue current topical therapy',
                autogenerated: true,
                maxCodingValue: 4,
                suggestedCodingValue: 3,
                order: 1,
                multipleItemValue: []
              }
            ]
          }
        ],
        groupCodes: {
          problemPointsV2: 3,
          dataPointsV2: 1,
          riskPointsV2: 3,
          emCode: '99214'
        },
        encounterNonBillableStatuses: {
          active: true,
          encounterId,
          billableEncounter: true,
          emCoding: true
        },
        patientId: patientId || 'mock-patient-id',
        notesCount: 1
        },
        careTeam: mockCareTeam
      };
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/progress/${encounterId}`, {
        params: patientId ? { patientId } : {},  // Only include patientId if provided
        headers: this.headers()
      });

      return {
        progressNote: response.data.data,
        careTeam: response.data.careTeam || []
      };
    } catch (error: any) {
      console.error('Error fetching progress note:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch progress note');
    }
  }

  /**
   * Create a ToDo for note deficiencies
   */
  async createToDo(encounterId: string): Promise<{ success: boolean; todoId?: string; message: string }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating ToDo creation');
      await new Promise(resolve => setTimeout(resolve, 500));
      return {
        success: true,
        todoId: `mock-todo-${Date.now()}`,
        message: 'Mock ToDo created successfully'
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/${encounterId}/create-todo`, {}, {
        headers: this.headers()
      });
      return response.data;
    } catch (error: any) {
      console.error('Error creating ToDo:', error);
      throw new Error(error.response?.data?.error || 'Failed to create ToDo');
    }
  }

  /**
   * Check a specific note with AI
   */
  async checkSingleNote(
    encounterId: string,
    patientId: string,
    patientName: string,
    chiefComplaint: string,
    dateOfService: string,
    force: boolean = false
  ): Promise<NoteCheckResult> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating AI note check');
      await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate AI processing time
      
      // Return a random result for demo purposes
      const randomResult = this.mockNoteCheckResults[Math.floor(Math.random() * this.mockNoteCheckResults.length)];
      return {
        ...randomResult,
        id: Date.now(),
        encounterId,
        patientId,
        patientName,
        chiefComplaint,
        dateOfService,
        checkedAt: new Date().toISOString()
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/check/${encounterId}`, {
        patientId,
        patientName,
        chiefComplaint,
        dateOfService,
        force
      }, {
        headers: this.headers()
      });

      return response.data.result;
    } catch (error: any) {
      console.error('Error checking note:', error);
      throw new Error(error.response?.data?.error || 'Failed to check note');
    }
  }

  /**
   * Process all eligible encounters in batch
   */
  async processAllEligibleNotes(): Promise<BatchProcessResult> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating batch processing');
      await new Promise(resolve => setTimeout(resolve, 3000)); // Simulate batch processing time
      
      return {
        processed: this.mockEligibleEncounters.length,
        successful: 2,
        failed: 1,
        results: this.mockNoteCheckResults
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/check-all`, {}, {
        headers: this.headers()
      });

      return {
        processed: response.data.processed || 0,
        successful: response.data.successful || 0,
        failed: response.data.failed || 0,
        results: response.data.results || []
      };
    } catch (error: any) {
      console.error('Error processing all notes:', error);
      throw new Error(error.response?.data?.error || 'Failed to process all notes');
    }
  }



  /**
   * Get note check results with pagination
   */
  async getNoteCheckResults(limit: number = 50, offset: number = 0): Promise<NoteCheckResult[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock note check results');
      await new Promise(resolve => setTimeout(resolve, 300)); // Simulate API delay
      
      // Apply pagination to mock data
      const start = offset;
      const end = start + limit;
      return this.mockNoteCheckResults.slice(start, end);
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/results`, {
        params: { limit, offset },
        headers: this.headers()
      });

      return response.data.results || [];
    } catch (error: any) {
      console.error('Error fetching note check results:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch note check results');
    }
  }

  /**
   * Get specific note check result
   */
  async getNoteCheckResult(encounterId: string): Promise<NoteCheckResult | null> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Finding mock note check result');
      await new Promise(resolve => setTimeout(resolve, 200)); // Simulate API delay
      
      return this.mockNoteCheckResults.find(result => result.encounterId === encounterId) || null;
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/result/${encounterId}`, {
        headers: this.headers()
      });

      return response.data.result;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null; // Not found
      }
      console.error('Error fetching note check result:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch note check result');
    }
  }

  /**
   * Get AI check history for specific encounter
   */
  async getNoteCheckHistory(encounterId: string): Promise<NoteCheckResult[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Finding mock note check history');
      await new Promise(resolve => setTimeout(resolve, 200)); // Simulate API delay
      
      return this.mockNoteCheckResults.filter(result => result.encounterId === encounterId);
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/history/${encounterId}`, {
        headers: this.headers()
      });

      return response.data.history;
    } catch (error: any) {
      console.error('Error fetching note check history:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch note check history');
    }
  }

  /**
   * Format time ago from ISO string
   */
  formatTimeAgo(isoString: string): string {
    const now = new Date();
    const then = new Date(isoString);
    const diffMs = now.getTime() - then.getTime();
    
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffMinutes < 1) return 'Just now';
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${diffDays}d ago`;
  }

  /**
   * Format date for display
   */
  formatDate(isoString: string): string {
    return new Date(isoString).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  /**
   * Get status color for UI
   */
  getStatusColor(status: string): string {
    switch (status) {
      case 'completed':
        return '#4CAF50';
      case 'pending':
        return '#FF9800';
      case 'error':
        return '#F44336';
      default:
        return '#757575';
    }
  }

  /**
   * Get status display text
   */
  getStatusText(status: string): string {
    switch (status) {
      case 'completed':
        return 'Completed';
      case 'pending':
        return 'Pending';
      case 'error':
        return 'Error';
      default:
        return status;
    }
  }

  /**
   * Get ToDo status for multiple encounters
   */
  async getTodoStatusForEncounters(encounterIds: string[]): Promise<Map<string, { todoCreated: boolean; todoCount: number }>> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock ToDo status');
      await new Promise(resolve => setTimeout(resolve, 200)); // Simulate API delay
      
      // Mock data - some encounters have ToDos created
      const mockStatuses = new Map<string, { todoCreated: boolean; todoCount: number }>();
      encounterIds.forEach((encounterId, index) => {
        // Mock: every 3rd encounter has a ToDo
        const hasTodo = index % 3 === 0;
        mockStatuses.set(encounterId, {
          todoCreated: hasTodo,
          todoCount: hasTodo ? Math.floor(Math.random() * 3) + 1 : 0
        });
      });
      return mockStatuses;
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/todos/bulk-status`, {
        encounterIds
      }, {
        headers: this.headers()
      });

      const statusMap = new Map<string, { todoCreated: boolean; todoCount: number }>();
      response.data.todoStatuses?.forEach((status: any) => {
        statusMap.set(status.encounterId, {
          todoCreated: status.todoCount > 0,
          todoCount: status.todoCount
        });
      });

      return statusMap;
    } catch (error: any) {
      console.error('Error fetching ToDo status:', error);
      // Return empty map on error instead of throwing
      return new Map();
    }
  }

  /**
   * Get created ToDos for an encounter
   */
  async getCreatedToDos(encounterId: string): Promise<CreatedToDo[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock created ToDos');
      await new Promise(resolve => setTimeout(resolve, 300)); // Simulate API delay
      
      // Mock data for created ToDos
      return [
        {
          id: 1,
          encounterId,
          patientId: 'mock-patient-1',
          patientName: 'John Doe',
          ezDermToDoId: 'mock-todo-123',
          subject: 'Note Deficiencies - 12/25/2023',
          description: 'Mock description',
          assignedTo: 'mock-provider-1',
          assignedToName: 'Dr. Smith',
          ccList: [],
          issuesCount: 2,
          createdBy: 'drgjoka',
          createdAt: new Date()
        }
      ];
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/${encounterId}/todos`, {
        headers: this.headers()
      });

      return response.data.todos || [];
    } catch (error: any) {
      console.error('Error fetching created ToDos:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch created ToDos');
    }
  }

  /**
   * Mark an issue as invalid
   */
  async markIssueAsInvalid(
    encounterId: string,
    checkId: number,
    issueIndex: number,
    issueType: string,
    assessment: string,
    issueHash: string,
    reason?: string
  ): Promise<{ success: boolean; message: string }> {
    try {
      const response = await axios.post(
        `${API_BASE_URL}/notes/${encounterId}/issues/${checkId}/${issueIndex}/mark-invalid`,
        {
          issueType,
          assessment,
          issueHash,
          reason
        },
        {
          headers: this.headers()
        }
      );
      return response.data;
    } catch (error: any) {
      console.error('Error marking issue as invalid:', error);
      throw new Error(error.response?.data?.error || 'Failed to mark issue as invalid');
    }
  }

  /**
   * Remove invalid marking from an issue
   */
  async unmarkIssueAsInvalid(
    encounterId: string,
    checkId: number,
    issueIndex: number
  ): Promise<{ success: boolean; message: string }> {
    try {
      const response = await axios.delete(
        `${API_BASE_URL}/notes/${encounterId}/issues/${checkId}/${issueIndex}/mark-invalid`,
        {
          headers: this.headers()
        }
      );
      return response.data;
    } catch (error: any) {
      console.error('Error removing invalid marking:', error);
      throw new Error(error.response?.data?.error || 'Failed to remove invalid marking');
    }
  }

  /**
   * Get invalid issues for an encounter
   */
  async getInvalidIssues(encounterId: string): Promise<InvalidIssue[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock invalid issues');
      return [];
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/${encounterId}/invalid-issues`, {
        headers: this.headers()
      });

      return response.data.invalidIssues || [];
    } catch (error: any) {
      console.error('Error fetching invalid issues:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch invalid issues');
    }
  }

  /**
   * Enqueue bulk force re-check jobs
   */
  async enqueueBulkForceRecheck(jobs: Array<{
    encounterId: string;
    patientId: string;
    patientName: string;
    chiefComplaint: string;
    dateOfService: string;
    force: boolean;
  }>): Promise<{ success: boolean; message: string; enqueuedCount: number }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating bulk force re-check job enqueue');
      return {
        success: true,
        message: `Enqueued ${jobs.length} notes for force re-check (mock mode)`,
        enqueuedCount: jobs.length
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/bulk-force-recheck`, 
        { jobs },
        {
          headers: this.headers()
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error enqueuing bulk force re-check jobs:', error);
      throw new Error(error.response?.data?.error || 'Failed to enqueue bulk force re-check jobs');
    }
  }

  /**
   * Enqueue bulk AI check jobs (without force)
   */
  async enqueueBulkCheck(jobs: Array<{
    encounterId: string;
    patientId: string;
    patientName: string;
    chiefComplaint: string;
    dateOfService: string;
  }>): Promise<{ success: boolean; message: string; enqueuedCount: number }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating bulk AI check job enqueue');
      return {
        success: true,
        message: `Enqueued ${jobs.length} notes for AI check (mock mode)`,
        enqueuedCount: jobs.length
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/bulk-check`, 
        { jobs },
        {
          headers: this.headers()
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error enqueuing bulk AI check jobs:', error);
      throw new Error(error.response?.data?.error || 'Failed to enqueue bulk AI check jobs');
    }
  }

  // Get current user's provider info
  async getCurrentUserProviderInfo(): Promise<{ username: string; providerId: string }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸ”„ Mock: Getting current user provider info');
      return {
        username: 'mockuser',
        providerId: 'dd0c986b-1b6d-4ade-89c8-f2b96d5958cc' // Mock provider ID from encounter.json
      };
    }

    try {
      const response = await axios.get(
        `${API_BASE_URL}/user/provider-info`,
        {
          headers: {
            'Authorization': `Bearer ${authService.getSessionToken()}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error getting current user provider info:', error);
      throw new Error(error.response?.data?.error || 'Failed to get current user provider info');
    }
  }

  // Sign off a note
  async signOffNote(encounterId: string, patientId: string): Promise<void> {
    if (USE_MOCK_DATA) {
      console.log('ðŸ”„ Mock: Signing off note', { encounterId, patientId });
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      return;
    }

    try {
      const response = await axios.post(
        `${API_BASE_URL}/notes/sign-off`,
        {
          encounterId,
          patientId,
          status: 'SIGNED_OFF'
        },
        {
          headers: {
            'Authorization': `Bearer ${authService.getSessionToken()}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error signing off note:', error);
      throw new Error(error.response?.data?.error || 'Failed to sign off note');
    }
  }

  // Modify HPI note section
  async modifyHPI(encounterId: string, patientId: string, noteText: string): Promise<{ type: string; encounterId: string; note: string }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸ”„ Mock: Modifying HPI', { encounterId, patientId, noteText });
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      return {
        type: 'HISTORY_OF_PRESENT_ILLNESS',
        encounterId,
        note: noteText
      };
    }

    try {
      const response = await axios.post(
        `${API_BASE_URL}/notes/modify-hpi`,
        {
          note: noteText,
          encounterId,
          patientId,
          type: 'HISTORY_OF_PRESENT_ILLNESS'
        },
        {
          headers: {
            'Authorization': `Bearer ${authService.getSessionToken()}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error modifying HPI:', error);
      throw new Error(error.response?.data?.error || 'Failed to modify HPI');
    }
  }

  // Get Assessment and Plan data
  async getAssessmentAndPlan(encounterId: string, patientId: string): Promise<any> {
    if (USE_MOCK_DATA) {
      console.log('ðŸ”„ Mock: Getting Assessment and Plan', { encounterId, patientId });
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 500));
      return {
        orderedItems: [],
        apSections: [
          {
            encounterMedicalProblemInfo: {
              id: "5359A557-C0D8-4C7E-8F5B-87377B08E9BC",
              problemPointsV2: "CHRONIC_MILD",
              name: "Assessment #1"
            },
            encounterMedicalProblemSectionElements: [
              {
                id: "problem-1",
                type: "PROBLEM_POINTS",
                title: "Problem",
                text: "Chronic - Mildly Worse"
              }
            ]
          }
        ]
      };
    }

    try {
      const response = await axios.post(
        `${API_BASE_URL}/assessment-plan/get`,
        {
          withExamLevel: true,
          encounterId,
          refresh: false
        },
        {
          headers: {
            'Authorization': `Bearer ${authService.getSessionToken()}`,
            'Content-Type': 'application/json',
            'encounterid': encounterId,
            'patientid': patientId
          }
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error getting Assessment and Plan:', error);
      throw new Error(error.response?.data?.error || 'Failed to get Assessment and Plan');
    }
  }

  // Update Problem field in Assessment and Plan
  async updateProblemField(encounterId: string, patientId: string, problemId: string, problemValue: string): Promise<any> {
    if (USE_MOCK_DATA) {
      console.log('ðŸ”„ Mock: Updating Problem field', { encounterId, patientId, problemId, problemValue });
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      return {
        success: true,
        message: 'Problem field updated successfully'
      };
    }

    try {
      const response = await axios.post(
        `${API_BASE_URL}/assessment-plan/update-problem`,
        {
          encounterId,
          patientId,
          problemId,
          problemValue
        },
        {
          headers: {
            'Authorization': `Bearer ${authService.getSessionToken()}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error updating Problem field:', error);
      throw new Error(error.response?.data?.error || 'Failed to update Problem field');
    }
  }
}

const aiNoteCheckerService = new AINoteCheckerService();
export default aiNoteCheckerService;
