import axios from 'axios';
import authService from './auth.service';

const API_BASE_URL = process.env.REACT_APP_API_URL ? `${process.env.REACT_APP_API_URL}/api` : 'http://localhost:5001/api';
const USE_MOCK_DATA = process.env.NODE_ENV === 'development' && process.env.REACT_APP_USE_MOCK_DATA === 'true';

// Types for AI Note Checker
export interface EligibleEncounter {
  encounterId: string;
  patientId: string;
  patientName: string;
  chiefComplaint: string;
  dateOfService: string;
  status: string;
}

export interface AIAnalysisIssue {
  assessment: string;
  issue: 'no_explicit_plan' | 'chronicity_mismatch' | 'unclear_documentation' | 'chief_complaint_structure';
  details: {
    HPI?: string;
    'A&P': string;
    correction: string;
  };
}

export interface AIAnalysisResult {
  issues?: AIAnalysisIssue[];
  status: 'ok' | 'corrections_needed';
  summary?: string;
}

export interface NoteCheckResult {
  id: number;
  encounterId: string;
  patientId: string;
  patientName: string;
  chiefComplaint: string;
  dateOfService: string;
  status: 'pending' | 'completed' | 'error';
  aiAnalysis?: AIAnalysisResult;
  issuesFound: boolean;
  checkedAt: string;
  checkedBy: string;
  errorMessage?: string;
}

export interface BatchProcessResult {
  processed: number;
  successful: number;
  failed: number;
  results: NoteCheckResult[];
}

export interface CareTeamMember {
  id: string;
  active: boolean;
  providerId: string;
  encounterId: string;
  encounterRoleType: 'PROVIDER' | 'SECONDARY_PROVIDER' | 'STAFF' | 'COSIGNING_PROVIDER';
  firstName: string;
  lastName: string;
  title?: string;
  onlineCheckInEnabled: boolean;
  fullOnlineCheckInEnabled: boolean;
}

export interface CreatedToDo {
  id: number;
  encounterId: string;
  patientId: string;
  patientName: string;
  ezDermToDoId: string;
  subject: string;
  description: string;
  assignedTo: string;
  assignedToName: string;
  ccList: any[];
  issuesCount: number;
  createdBy: string;
  createdAt: Date;
}

export interface InvalidIssue {
  id: number;
  encounterId: string;
  checkId: number;
  issueIndex: number;
  issueType: string;
  assessment: string;
  issueHash: string;
  markedInvalidBy: string;
  markedInvalidAt: Date;
  reason?: string;
}

export interface ProgressNoteResponse {
  progressNotes: Array<{
    sectionType: 'SUBJECTIVE' | 'OBJECTIVE' | 'ASSESSMENT_AND_PLAN';
    locked: boolean;
    order: number;
    items: Array<{
      elementType: string;
      text: string;
      autogenerated: boolean;
      maxCodingValue: number;
      suggestedCodingValue: number;
      order: number;
      note?: string;
      multipleItemValue: any[];
    }>;
  }>;
  groupCodes: {
    problemPointsV2: number;
    dataPointsV2: number;
    riskPointsV2: number;
    emCode: string;
  };
  encounterNonBillableStatuses: {
    active: boolean;
    encounterId: string;
    billableEncounter: boolean;
    emCoding: boolean;
  };
  patientId: string;
  notesCount: number;
}

class AINoteCheckerService {
  private readonly headers = () => {
    const token = authService.getSessionToken();
    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    };
  };

  // Mock data for development
  private mockEligibleEncounters: EligibleEncounter[] = [
    {
      encounterId: 'mock-encounter-1',
      patientId: 'mock-patient-1',
      patientName: 'John Doe',
      chiefComplaint: 'Follow-up psoriasis',
      dateOfService: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
      status: 'PENDING_COSIGN'
    },
    {
      encounterId: 'mock-encounter-2',
      patientId: 'mock-patient-2',
      patientName: 'Jane Smith',
      chiefComplaint: 'Skin lesion check',
      dateOfService: new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString(),
      status: 'CHECKED_OUT'
    },
    {
      encounterId: 'mock-encounter-3',
      patientId: 'mock-patient-3',
      patientName: 'Mike Johnson',
      chiefComplaint: 'Acne treatment',
      dateOfService: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
      status: 'WITH_PROVIDER'
    }
  ];

  private mockNoteCheckResults: NoteCheckResult[] = [
    {
      id: 1,
      encounterId: 'mock-encounter-1',
      patientId: 'mock-patient-1',
      patientName: 'John Doe',
      chiefComplaint: 'Follow-up psoriasis',
      dateOfService: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
      status: 'completed',
      aiAnalysis: {
        status: 'corrections_needed',
        issues: [
          {
            assessment: 'Psoriasis vulgaris',
            issue: 'chronicity_mismatch',
            details: {
              HPI: 'Patient presents for follow-up',
              'A&P': 'Listed as acute condition but history indicates chronic psoriasis',
              correction: 'Document as chronic condition and include duration'
            }
          }
        ],
        summary: 'Chronicity documentation needs correction for proper coding'
      },
      issuesFound: true,
      checkedAt: new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user'
    },
    {
      id: 2,
      encounterId: 'mock-encounter-2',
      patientId: 'mock-patient-2',
      patientName: 'Jane Smith',
      chiefComplaint: 'Skin lesion check',
      dateOfService: new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString(),
      status: 'completed',
      aiAnalysis: {
        status: 'ok'
      },
      issuesFound: false,
      checkedAt: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user'
    },
    {
      id: 3,
      encounterId: 'mock-encounter-3',
      patientId: 'mock-patient-3',
      patientName: 'Mike Johnson',
      chiefComplaint: 'Acne treatment',
      dateOfService: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
      status: 'error',
      issuesFound: false,
      checkedAt: new Date(Date.now() - 10 * 60 * 1000).toISOString(),
      checkedBy: 'demo-user',
      errorMessage: 'Claude API rate limit exceeded'
    }
  ];

  /**
   * Get all incomplete notes from EZDerm
   */
  async getIncompleteNotes(): Promise<EligibleEncounter[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock incomplete notes');
      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
      return this.mockEligibleEncounters;
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/incomplete`, 
        { fetchFrom: 0, size: 100 },
        {
          headers: this.headers()
        }
      );

      return response.data.encounters || [];
    } catch (error: any) {
      console.error('Error fetching incomplete notes:', error);
      throw new Error('Failed to fetch incomplete notes: ' + (error.response?.data?.error || error.message));
    }
  }

  /**
   * Get all encounters eligible for AI note checking
   */
  async getEligibleEncounters(): Promise<EligibleEncounter[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock eligible encounters');
      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
      return this.mockEligibleEncounters;
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/eligible`, {
        headers: this.headers()
      });

      return response.data.encounters || [];
    } catch (error: any) {
      console.error('Error fetching eligible encounters:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch eligible encounters');
    }
  }

  /**
   * Get progress note details for a specific encounter
   */
  async getProgressNote(encounterId: string, patientId?: string): Promise<{ progressNote: ProgressNoteResponse; careTeam: CareTeamMember[] }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock progress note');
      await new Promise(resolve => setTimeout(resolve, 800)); // Simulate API delay
      
      const mockCareTeam: CareTeamMember[] = [
        {
          id: 'mock-role-1',
          active: true,
          providerId: 'mock-provider-1',
          encounterId,
          encounterRoleType: 'PROVIDER',
          firstName: 'Dr. Sarah',
          lastName: 'Smith',
          title: 'MD',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        },
        {
          id: 'mock-role-2',
          active: true,
          providerId: 'mock-provider-2',
          encounterId,
          encounterRoleType: 'SECONDARY_PROVIDER',
          firstName: 'Jane',
          lastName: 'Wilson',
          title: 'NP',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        },
        {
          id: 'mock-role-3',
          active: true,
          providerId: 'mock-provider-3',
          encounterId,
          encounterRoleType: 'STAFF',
          firstName: 'Mike',
          lastName: 'Johnson',
          title: 'MA',
          onlineCheckInEnabled: false,
          fullOnlineCheckInEnabled: false
        }
      ];

      return {
        progressNote: {
          progressNotes: [
          {
            sectionType: 'SUBJECTIVE',
            locked: true,
            order: 1,
            items: [
              {
                elementType: 'HISTORY_OF_PRESENT_ILLNESS',
                text: 'Patient returns for follow-up of chronic psoriasis. Reports improved symptoms with current treatment.',
                autogenerated: true,
                maxCodingValue: 0,
                suggestedCodingValue: 0,
                order: 1,
                multipleItemValue: []
              }
            ]
          },
          {
            sectionType: 'ASSESSMENT_AND_PLAN',
            locked: true,
            order: 3,
            items: [
              {
                elementType: 'ASSESSMENT_AND_PLAN',
                text: '1. Psoriasis vulgaris\n\tâ€¢\tProblem: Chronic - Stable\n\tâ€¢\tPlan: Continue current topical therapy',
                autogenerated: true,
                maxCodingValue: 4,
                suggestedCodingValue: 3,
                order: 1,
                multipleItemValue: []
              }
            ]
          }
        ],
        groupCodes: {
          problemPointsV2: 3,
          dataPointsV2: 1,
          riskPointsV2: 3,
          emCode: '99214'
        },
        encounterNonBillableStatuses: {
          active: true,
          encounterId,
          billableEncounter: true,
          emCoding: true
        },
        patientId: patientId || 'mock-patient-id',
        notesCount: 1
        },
        careTeam: mockCareTeam
      };
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/progress/${encounterId}`, {
        params: patientId ? { patientId } : {},  // Only include patientId if provided
        headers: this.headers()
      });

      return {
        progressNote: response.data.data,
        careTeam: response.data.careTeam || []
      };
    } catch (error: any) {
      console.error('Error fetching progress note:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch progress note');
    }
  }

  /**
   * Create a ToDo for note deficiencies
   */
  async createToDo(encounterId: string): Promise<{ success: boolean; todoId?: string; message: string }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating ToDo creation');
      await new Promise(resolve => setTimeout(resolve, 500));
      return {
        success: true,
        todoId: `mock-todo-${Date.now()}`,
        message: 'Mock ToDo created successfully'
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/${encounterId}/create-todo`, {}, {
        headers: this.headers()
      });
      return response.data;
    } catch (error: any) {
      console.error('Error creating ToDo:', error);
      throw new Error(error.response?.data?.error || 'Failed to create ToDo');
    }
  }

  /**
   * Check a specific note with AI
   */
  async checkSingleNote(
    encounterId: string,
    patientId: string,
    patientName: string,
    chiefComplaint: string,
    dateOfService: string,
    force: boolean = false
  ): Promise<NoteCheckResult> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating AI note check');
      await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate AI processing time
      
      // Return a random result for demo purposes
      const randomResult = this.mockNoteCheckResults[Math.floor(Math.random() * this.mockNoteCheckResults.length)];
      return {
        ...randomResult,
        id: Date.now(),
        encounterId,
        patientId,
        patientName,
        chiefComplaint,
        dateOfService,
        checkedAt: new Date().toISOString()
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/check/${encounterId}`, {
        patientId,
        patientName,
        chiefComplaint,
        dateOfService,
        force
      }, {
        headers: this.headers()
      });

      return response.data.result;
    } catch (error: any) {
      console.error('Error checking note:', error);
      throw new Error(error.response?.data?.error || 'Failed to check note');
    }
  }

  /**
   * Process all eligible encounters in batch
   */
  async processAllEligibleNotes(): Promise<BatchProcessResult> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating batch processing');
      await new Promise(resolve => setTimeout(resolve, 3000)); // Simulate batch processing time
      
      return {
        processed: this.mockEligibleEncounters.length,
        successful: 2,
        failed: 1,
        results: this.mockNoteCheckResults
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/check-all`, {}, {
        headers: this.headers()
      });

      return {
        processed: response.data.processed || 0,
        successful: response.data.successful || 0,
        failed: response.data.failed || 0,
        results: response.data.results || []
      };
    } catch (error: any) {
      console.error('Error processing all notes:', error);
      throw new Error(error.response?.data?.error || 'Failed to process all notes');
    }
  }



  /**
   * Get note check results with pagination
   */
  async getNoteCheckResults(limit: number = 50, offset: number = 0): Promise<NoteCheckResult[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock note check results');
      await new Promise(resolve => setTimeout(resolve, 300)); // Simulate API delay
      
      // Apply pagination to mock data
      const start = offset;
      const end = start + limit;
      return this.mockNoteCheckResults.slice(start, end);
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/results`, {
        params: { limit, offset },
        headers: this.headers()
      });

      return response.data.results || [];
    } catch (error: any) {
      console.error('Error fetching note check results:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch note check results');
    }
  }

  /**
   * Get specific note check result
   */
  async getNoteCheckResult(encounterId: string): Promise<NoteCheckResult | null> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Finding mock note check result');
      await new Promise(resolve => setTimeout(resolve, 200)); // Simulate API delay
      
      return this.mockNoteCheckResults.find(result => result.encounterId === encounterId) || null;
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/result/${encounterId}`, {
        headers: this.headers()
      });

      return response.data.result;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null; // Not found
      }
      console.error('Error fetching note check result:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch note check result');
    }
  }

  /**
   * Format time ago from ISO string
   */
  formatTimeAgo(isoString: string): string {
    const now = new Date();
    const then = new Date(isoString);
    const diffMs = now.getTime() - then.getTime();
    
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffMinutes < 1) return 'Just now';
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${diffDays}d ago`;
  }

  /**
   * Format date for display
   */
  formatDate(isoString: string): string {
    return new Date(isoString).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  /**
   * Get status color for UI
   */
  getStatusColor(status: string): string {
    switch (status) {
      case 'completed':
        return '#4CAF50';
      case 'pending':
        return '#FF9800';
      case 'error':
        return '#F44336';
      default:
        return '#757575';
    }
  }

  /**
   * Get status display text
   */
  getStatusText(status: string): string {
    switch (status) {
      case 'completed':
        return 'Completed';
      case 'pending':
        return 'Pending';
      case 'error':
        return 'Error';
      default:
        return status;
    }
  }

  /**
   * Get created ToDos for an encounter
   */
  async getCreatedToDos(encounterId: string): Promise<CreatedToDo[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock created ToDos');
      await new Promise(resolve => setTimeout(resolve, 300)); // Simulate API delay
      
      // Mock data for created ToDos
      return [
        {
          id: 1,
          encounterId,
          patientId: 'mock-patient-1',
          patientName: 'John Doe',
          ezDermToDoId: 'mock-todo-123',
          subject: 'Note Deficiencies - 12/25/2023',
          description: 'Mock description',
          assignedTo: 'mock-provider-1',
          assignedToName: 'Dr. Smith',
          ccList: [],
          issuesCount: 2,
          createdBy: 'drgjoka',
          createdAt: new Date()
        }
      ];
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/${encounterId}/todos`, {
        headers: this.headers()
      });

      return response.data.todos || [];
    } catch (error: any) {
      console.error('Error fetching created ToDos:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch created ToDos');
    }
  }

  /**
   * Mark an issue as invalid
   */
  async markIssueAsInvalid(
    encounterId: string,
    checkId: number,
    issueIndex: number,
    issueType: string,
    assessment: string,
    issueHash: string,
    reason?: string
  ): Promise<{ success: boolean; message: string }> {
    try {
      const response = await axios.post(
        `${API_BASE_URL}/notes/${encounterId}/issues/${checkId}/${issueIndex}/mark-invalid`,
        {
          issueType,
          assessment,
          issueHash,
          reason
        },
        {
          headers: this.headers()
        }
      );
      return response.data;
    } catch (error: any) {
      console.error('Error marking issue as invalid:', error);
      throw new Error(error.response?.data?.error || 'Failed to mark issue as invalid');
    }
  }

  /**
   * Remove invalid marking from an issue
   */
  async unmarkIssueAsInvalid(
    encounterId: string,
    checkId: number,
    issueIndex: number
  ): Promise<{ success: boolean; message: string }> {
    try {
      const response = await axios.delete(
        `${API_BASE_URL}/notes/${encounterId}/issues/${checkId}/${issueIndex}/mark-invalid`,
        {
          headers: this.headers()
        }
      );
      return response.data;
    } catch (error: any) {
      console.error('Error removing invalid marking:', error);
      throw new Error(error.response?.data?.error || 'Failed to remove invalid marking');
    }
  }

  /**
   * Get invalid issues for an encounter
   */
  async getInvalidIssues(encounterId: string): Promise<InvalidIssue[]> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Returning mock invalid issues');
      return [];
    }

    try {
      const response = await axios.get(`${API_BASE_URL}/notes/${encounterId}/invalid-issues`, {
        headers: this.headers()
      });

      return response.data.invalidIssues || [];
    } catch (error: any) {
      console.error('Error fetching invalid issues:', error);
      throw new Error(error.response?.data?.error || 'Failed to fetch invalid issues');
    }
  }

  /**
   * Enqueue bulk force re-check jobs
   */
  async enqueueBulkForceRecheck(jobs: Array<{
    encounterId: string;
    patientId: string;
    patientName: string;
    chiefComplaint: string;
    dateOfService: string;
    force: boolean;
  }>): Promise<{ success: boolean; message: string; enqueuedCount: number }> {
    if (USE_MOCK_DATA) {
      console.log('ðŸš§ Development Mode: Simulating bulk force re-check job enqueue');
      return {
        success: true,
        message: `Enqueued ${jobs.length} notes for force re-check (mock mode)`,
        enqueuedCount: jobs.length
      };
    }

    try {
      const response = await axios.post(`${API_BASE_URL}/notes/bulk-force-recheck`, 
        { jobs },
        {
          headers: this.headers()
        }
      );

      return response.data;
    } catch (error: any) {
      console.error('Error enqueuing bulk force re-check jobs:', error);
      throw new Error(error.response?.data?.error || 'Failed to enqueue bulk force re-check jobs');
    }
  }
}

const aiNoteCheckerService = new AINoteCheckerService();
export default aiNoteCheckerService;
